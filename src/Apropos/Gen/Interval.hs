{- |
Module: Apropos.Gen.Interval
Description: Plutus interval generators.
Maintainer: jack@mlabs.city

`Gen`s for `Plutus.V1.Ledger.Interval` types.
-}
module Apropos.Gen.Interval (interval, extendedF, extendedI) where

import Apropos.Gen (Gen, element)
import Plutus.V1.Ledger.Interval (
  Extended (Finite, NegInf, PosInf),
  Interval (Interval),
  LowerBound (LowerBound),
  UpperBound (UpperBound),
 )

{- | Given two generators for a type @a@, will return a generator
     for type `Interval` @a@, where the lower bound has been
     generated by the first generator and the upper bound
     by the second.
-}
interval ::
  Show a =>
  Gen a -> -- Generator for the lower bound.
  Gen a -> -- Generator for the upper bound.
  Gen (Interval a) -- Generator for the interval.
interval g0 g1 = do
  l <- lowerBound g0
  u <- upperBound g1
  return $ Interval l u

{- | Given a generator for a type @a@, will return a generator
     for type `LowerBound` @a@.
-}
lowerBound :: Show a => Gen a -> Gen (LowerBound a)
lowerBound g = do
  e <- extendedF g
  c <- element [True, False]
  return $ LowerBound e c

{- | Given a generator for a type @a@, will return a generator
     for type `UpperBound` @a@.
-}
upperBound :: Show a => Gen a -> Gen (UpperBound a)
upperBound g = do
  e <- extendedF g
  c <- element [True, False]
  return $ UpperBound e c

-- | Generator for `Extended` @a@ that must be finite.
extendedF :: Show a => Gen a -> Gen (Extended a)
extendedF = extended False

-- | Generator for `Extended` @a@ that can be infinite.
extendedI :: Show a => Gen a -> Gen (Extended a)
extendedI = extended True

extended :: Show a => Bool -> Gen a -> Gen (Extended a)
extended allowInfinite g = do
  x <- g
  if allowInfinite
    then element [NegInf, Finite x, PosInf]
    else return $ Finite x
